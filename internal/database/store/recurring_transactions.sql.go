// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: recurring_transactions.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const createOccurrence = `-- name: CreateOccurrence :one
INSERT INTO recurring_transaction_occurrences (
    recurring_transaction_id,
    transaction_id,
    occurrence_date
) VALUES ($1, $2, $3)
RETURNING id, created_at, recurring_transaction_id, transaction_id, occurrence_date
`

type CreateOccurrenceParams struct {
	RecurringTransactionID int32     `json:"recurring_transaction_id"`
	TransactionID          int32     `json:"transaction_id"`
	OccurrenceDate         time.Time `json:"occurrence_date"`
}

func (q *Queries) CreateOccurrence(ctx context.Context, arg CreateOccurrenceParams) (RecurringTransactionOccurrence, error) {
	row := q.db.QueryRowContext(ctx, createOccurrence, arg.RecurringTransactionID, arg.TransactionID, arg.OccurrenceDate)
	var i RecurringTransactionOccurrence
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.RecurringTransactionID,
		&i.TransactionID,
		&i.OccurrenceDate,
	)
	return i, err
}

const createRecurringTransaction = `-- name: CreateRecurringTransaction :one
INSERT INTO recurring_transactions (
    account_id,
    amount_cents,
    category_id,
    title,
    note,
    frequency,
    interval,
    start_date,
    end_date,
    day_month,
    day_week,
    max_occurrences,
    is_active
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, created_at, updated_at, version, account_id, amount_cents, category_id, title, note, frequency, interval, start_date, end_date, day_month, day_week, max_occurrences, is_active
`

type CreateRecurringTransactionParams struct {
	AccountID      int32               `json:"account_id"`
	AmountCents    int32               `json:"amount_cents"`
	CategoryID     int32               `json:"category_id"`
	Title          string              `json:"title"`
	Note           string              `json:"note"`
	Frequency      RecurrenceFrequency `json:"frequency"`
	Interval       int32               `json:"interval"`
	StartDate      time.Time           `json:"start_date"`
	EndDate        sql.NullTime        `json:"end_date"`
	DayMonth       sql.NullInt32       `json:"day_month"`
	DayWeek        sql.NullInt32       `json:"day_week"`
	MaxOccurrences sql.NullInt32       `json:"max_occurrences"`
	IsActive       bool                `json:"is_active"`
}

func (q *Queries) CreateRecurringTransaction(ctx context.Context, arg CreateRecurringTransactionParams) (RecurringTransaction, error) {
	row := q.db.QueryRowContext(ctx, createRecurringTransaction,
		arg.AccountID,
		arg.AmountCents,
		arg.CategoryID,
		arg.Title,
		arg.Note,
		arg.Frequency,
		arg.Interval,
		arg.StartDate,
		arg.EndDate,
		arg.DayMonth,
		arg.DayWeek,
		arg.MaxOccurrences,
		arg.IsActive,
	)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.AccountID,
		&i.AmountCents,
		&i.CategoryID,
		&i.Title,
		&i.Note,
		&i.Frequency,
		&i.Interval,
		&i.StartDate,
		&i.EndDate,
		&i.DayMonth,
		&i.DayWeek,
		&i.MaxOccurrences,
		&i.IsActive,
	)
	return i, err
}

const deleteRecurringTransaction = `-- name: DeleteRecurringTransaction :execresult
DELETE FROM recurring_transactions
USING accounts
WHERE recurring_transactions.account_id = accounts.id
  AND recurring_transactions.id = $1
  AND accounts.user_id = $2
`

type DeleteRecurringTransactionParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteRecurringTransaction(ctx context.Context, arg DeleteRecurringTransactionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteRecurringTransaction, arg.ID, arg.UserID)
}

const getActiveRecurringTransactions = `-- name: GetActiveRecurringTransactions :many
SELECT rt.id, rt.created_at, rt.updated_at, rt.version, rt.account_id, rt.amount_cents, rt.category_id, rt.title, rt.note, rt.frequency, rt.interval, rt.start_date, rt.end_date, rt.day_month, rt.day_week, rt.max_occurrences, rt.is_active FROM recurring_transactions rt
INNER JOIN accounts ON rt.account_id = accounts.id
WHERE accounts.user_id = $1 
  AND rt.is_active = true
  AND rt.start_date <= $2
  AND (rt.end_date IS NULL OR rt.end_date >= $2)
`

type GetActiveRecurringTransactionsParams struct {
	UserID    int32     `json:"user_id"`
	StartDate time.Time `json:"start_date"`
}

func (q *Queries) GetActiveRecurringTransactions(ctx context.Context, arg GetActiveRecurringTransactionsParams) ([]RecurringTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRecurringTransactions, arg.UserID, arg.StartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurringTransaction
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.AccountID,
			&i.AmountCents,
			&i.CategoryID,
			&i.Title,
			&i.Note,
			&i.Frequency,
			&i.Interval,
			&i.StartDate,
			&i.EndDate,
			&i.DayMonth,
			&i.DayWeek,
			&i.MaxOccurrences,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastOccurrence = `-- name: GetLastOccurrence :one
SELECT id, created_at, recurring_transaction_id, transaction_id, occurrence_date FROM recurring_transaction_occurrences
WHERE recurring_transaction_id = $1
ORDER BY occurrence_date DESC
LIMIT 1
`

func (q *Queries) GetLastOccurrence(ctx context.Context, recurringTransactionID int32) (RecurringTransactionOccurrence, error) {
	row := q.db.QueryRowContext(ctx, getLastOccurrence, recurringTransactionID)
	var i RecurringTransactionOccurrence
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.RecurringTransactionID,
		&i.TransactionID,
		&i.OccurrenceDate,
	)
	return i, err
}

const getOccurrenceForDate = `-- name: GetOccurrenceForDate :one
SELECT id, created_at, recurring_transaction_id, transaction_id, occurrence_date FROM recurring_transaction_occurrences
WHERE recurring_transaction_id = $1 AND occurrence_date = $2
`

type GetOccurrenceForDateParams struct {
	RecurringTransactionID int32     `json:"recurring_transaction_id"`
	OccurrenceDate         time.Time `json:"occurrence_date"`
}

func (q *Queries) GetOccurrenceForDate(ctx context.Context, arg GetOccurrenceForDateParams) (RecurringTransactionOccurrence, error) {
	row := q.db.QueryRowContext(ctx, getOccurrenceForDate, arg.RecurringTransactionID, arg.OccurrenceDate)
	var i RecurringTransactionOccurrence
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.RecurringTransactionID,
		&i.TransactionID,
		&i.OccurrenceDate,
	)
	return i, err
}

const getOccurrences = `-- name: GetOccurrences :many
SELECT id, created_at, recurring_transaction_id, transaction_id, occurrence_date FROM recurring_transaction_occurrences
WHERE recurring_transaction_id = $1
`

func (q *Queries) GetOccurrences(ctx context.Context, recurringTransactionID int32) ([]RecurringTransactionOccurrence, error) {
	rows, err := q.db.QueryContext(ctx, getOccurrences, recurringTransactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurringTransactionOccurrence
	for rows.Next() {
		var i RecurringTransactionOccurrence
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.RecurringTransactionID,
			&i.TransactionID,
			&i.OccurrenceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringTransactionByID = `-- name: GetRecurringTransactionByID :one
SELECT rt.id, rt.created_at, rt.updated_at, rt.version, rt.account_id, rt.amount_cents, rt.category_id, rt.title, rt.note, rt.frequency, rt.interval, rt.start_date, rt.end_date, rt.day_month, rt.day_week, rt.max_occurrences, rt.is_active FROM recurring_transactions rt
INNER JOIN accounts ON rt.account_id = accounts.id
WHERE rt.id = $1 AND accounts.user_id = $2
`

type GetRecurringTransactionByIDParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetRecurringTransactionByID(ctx context.Context, arg GetRecurringTransactionByIDParams) (RecurringTransaction, error) {
	row := q.db.QueryRowContext(ctx, getRecurringTransactionByID, arg.ID, arg.UserID)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.AccountID,
		&i.AmountCents,
		&i.CategoryID,
		&i.Title,
		&i.Note,
		&i.Frequency,
		&i.Interval,
		&i.StartDate,
		&i.EndDate,
		&i.DayMonth,
		&i.DayWeek,
		&i.MaxOccurrences,
		&i.IsActive,
	)
	return i, err
}

const getUserRecurringTransactions = `-- name: GetUserRecurringTransactions :many
SELECT rt.id, rt.created_at, rt.updated_at, rt.version, rt.account_id, rt.amount_cents, rt.category_id, rt.title, rt.note, rt.frequency, rt.interval, rt.start_date, rt.end_date, rt.day_month, rt.day_week, rt.max_occurrences, rt.is_active FROM recurring_transactions rt
INNER JOIN accounts ON rt.account_id = accounts.id
WHERE accounts.user_id = $1
`

func (q *Queries) GetUserRecurringTransactions(ctx context.Context, userID int32) ([]RecurringTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getUserRecurringTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurringTransaction
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.AccountID,
			&i.AmountCents,
			&i.CategoryID,
			&i.Title,
			&i.Note,
			&i.Frequency,
			&i.Interval,
			&i.StartDate,
			&i.EndDate,
			&i.DayMonth,
			&i.DayWeek,
			&i.MaxOccurrences,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecurringTransaction = `-- name: UpdateRecurringTransaction :execresult
UPDATE recurring_transactions
SET amount_cents = $1,
    category_id = $2,
    title = $3,
    note = $4,
    frequency = $5,
    interval = $6,
    end_date = $7,
    day_month = $8,
    day_week = $9,
    max_occurrences = $10,
    is_active = $11,
    version = version + 1,
    updated_at = NOW()
FROM accounts
WHERE recurring_transactions.account_id = accounts.id
  AND recurring_transactions.id = $12
  AND accounts.user_id = $13
  AND recurring_transactions.version = $14
`

type UpdateRecurringTransactionParams struct {
	AmountCents    int32               `json:"amount_cents"`
	CategoryID     int32               `json:"category_id"`
	Title          string              `json:"title"`
	Note           string              `json:"note"`
	Frequency      RecurrenceFrequency `json:"frequency"`
	Interval       int32               `json:"interval"`
	EndDate        sql.NullTime        `json:"end_date"`
	DayMonth       sql.NullInt32       `json:"day_month"`
	DayWeek        sql.NullInt32       `json:"day_week"`
	MaxOccurrences sql.NullInt32       `json:"max_occurrences"`
	IsActive       bool                `json:"is_active"`
	ID             int32               `json:"id"`
	UserID         int32               `json:"user_id"`
	Version        int32               `json:"-"`
}

func (q *Queries) UpdateRecurringTransaction(ctx context.Context, arg UpdateRecurringTransactionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateRecurringTransaction,
		arg.AmountCents,
		arg.CategoryID,
		arg.Title,
		arg.Note,
		arg.Frequency,
		arg.Interval,
		arg.EndDate,
		arg.DayMonth,
		arg.DayWeek,
		arg.MaxOccurrences,
		arg.IsActive,
		arg.ID,
		arg.UserID,
		arg.Version,
	)
}
